
\begin{figure}[ht]
\hrule\hrule
\centering
  \begin{slangmath}[numbers=left,emph={MergeModels, MkMap, MkModel,%
                    MergeData, MergeComp, MergeOp, MapSum}]
fun MergeModels($m_1, m_2, (r_c,r_O,r_D)$)
  let $h_D=$ map(($\lambda D_1,D_2 \cdot$($D_1,$MergeData($D_1, D_2$))), $r_D$)
  let $h_C=$ map(($\lambda C_1,C_2 \cdot$ let $C'=\; $MergeComp($C_1, C_2$) in [$(C_1, C'),\; (C_2, C')$]), $r_C$)
  MkModel($m_1, m_2, h_C, h_D$)

fun MkModel($m_1, m_2, h_C, h_D$)
  let $f_{map} = \lambda h,e \cdot (e \in dom(h)) \;?\; \{h[e]\} : \{e\}$
  (MapSum($m_1.comps \cup m_2.comps,\; f_{map}(h_C)$), MapSum($m_1.data \cup m_2.data,\; f_{map}(h_D)$))

fun MergeData($D_1, D_2$)       \eqv MkEmbeddingFunc($D_1, D_2$)($D_1$)
fun MergeOp($O_1, O_2$)         \eqv let $O'=\; $MkEmbeddingFunc($O_1, O_2$)($O_1$)
                        $O'.args= O_1.args \cup O_2.args$ 
                        $O'$
fun MergeComp($c_1, c_2, r_O$)$\:$\eqv let $f_{map} = \lambda O_1,O_2 \cdot (O_1,O_2)\in r_O\;?\;$MergeOp($O_1,O_2$)$\;: O_1$
                        let $e = c_2.exports\;\cup\;$MapSum($c_1.exports \times c_2.exports,\; f_{map}$)
                        let $i = c_2.invokes\;\cup\;$MapSum($c_1.invokes \times c_2.invokes,\; f_{map}$)
                        $(e,\; i,\; c_1.stores \cup c_2.stores,\; c_1.guard \cup c_2.guard)$
fun MapSum($set, f_{map}$)          \eqv fold(($\lambda a, e \cdot a \cup e),\; \{\},\; f_{map}(set)$)
  \end{slangmath}
\hrule\vskip7pt
\caption{Algorithm for merging two models ($m_1$ and $m_2$) given a
  mapping ($r_C, r_O, r_D$).  The algorithm make use of the {\rmfamily
    MkEmbeddingFunc($set_1, set_2$)} function (which computes an
  embedding of $set_1$ into $set_2$ and returns a 1-arg function for
  mapping elements of $set_1$ to elements of $set_2$), as well as two
  standard library functions, \textbf{map}($\lambda_{map},\; set$) and
  \textbf{fold}($\lambda_{fold},\; init,\; set$).}
\label{fig-mergingin-alg-func}
%\label{alg-merge-models}
\end{figure}
