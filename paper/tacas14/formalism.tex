
\section{Formalism}
\label{sec-formalism}

% Before describing how we reconcile the types of mismatch that we
% discussed in Section~\ref{sec-mismatch}, we first introduce the
% underlying formalism that is used for specifying systems, attacks, and
% security properties.
This section introduces the underlying formalism that our framework
uses to specify a system and its behavior. We use a standard
first-order logic to describe the formalism.

\paragraph{\textbf{Structure}} In our approach, a system consists of a
set of components $C$ that asynchronously communicate with each other
through operations $O$.  Each component \textit{exports} zero or more
operations at its interface, and \textit{stores} some set of data
$D$\fix{ that can be transmitted}{. Data can flow from one} to another
component \fix{by \textit{invoking} the latter's operations}{only by
  means of operation \textit{invocations}; this enables our system to
  accurately track data flows and automatically check standard
  information flow properties such as \textit{integrity} and
  \textit{confidentiality}}.\am{This data flow business is certainly
  important, but I'm not sure it belongs here.  Maybe move it a few
  paragraphs below, where it talks about passing arguments.}.  For
example, consider the \textsf{NYTimes} server from
Figure~\ref{fig-nytimes}(a). One way to specify this component in our
approach is as follows\footnote{For convenience, we use the dot (.)
  notation to refer a tuple element by name; for example, $c.exports$
  refers to $exports$ element of component $c$.}:
\begin{align*}
&\textsf{NYTimes}.exports = \textsf{GetPage}\\
&\textsf{NYTimes}.invokes = \textsf{SendPage}\\
&\textsf{NYTimes}.stores(\textsf{articles}) \in
\textsf{Map[Link,Page]} \am{\mbox{why $\in$ and not $=$? \textsf{Map} is also undefined, as well as the \textsf{Map[K,V]} syntax}}
\end{align*}
where $\textsf{GetPage} \subseteq O$ is the type of operation that
corresponds to a request for an article page, and $\textsf{SendPage}
\subseteq O$ is the type of operation for transferring a page to
$\textsf{Client}$. $\textsf{Map[Link,Page]} \subseteq D$ represents a
type of data structure that maps a link to a page. \am{No
  need to explain these operations/datatypes again}

\begin{figure}[!t]
\fbox{
\begin{minipage}[t]{0.455\textwidth}
\begin{tabular}{@{\quad}l@{\quad}l}
\multicolumn{2}{l}{\textbf{Sorts}} \\
$C, O, D, V$                    & \\
$N, F$                          & \color{comment} // Name, Formula\\
\\
\multicolumn{2}{l}{\textbf{Component} ($C$)} \\
$exports : \mathcal P (O)$      & \color{comment} // exported ops \\
$invokes : \mathcal P (O)$      & \color{comment} // invoked ops \\
$stores : N \pfun \mathcal P (D)$            & \color{comment} // stored data \\
$cons : O \pfun F$ & \color{comment} // constraints \ 
\end{tabular}
\end{minipage}
\quad
\begin{minipage}[t]{0.455\textwidth}
\begin{tabular}{@{\quad}l@{\quad}l}
\multicolumn{2}{l}{\textbf{Operation} ($O$)} \\
$args : N \pfun \mathcal P (D)$       & \color{comment} // arguments \\
\\
\multicolumn{2}{l}{\textbf{Data} ($D$)} \\
\\
\multicolumn{2}{l}{\textbf{Model} ($V$)} \\
$comps : \mathcal P (C)$  & \color{comment} // components \\
$data : \mathcal P (D)$  & \color{comment} // data types \\
\end{tabular}
\end{minipage}
}
\caption{Basic components of our modeling formalism.}
\label{fig-formalism}
\end{figure}

\begin{figure}[!t]
\fbox{
\begin{minipage}[t]{0.95\textwidth}
$\textsf{Paywall}.comps = \{\textsf{NYTimes}, \textsf{Client},
\textsf{Reader}\}$ 

$\textsf{Paywall}.data = \textsf{Article} \cup \textsf{Link} \cup
\textsf{Counter}$ 

$\textsf{NYTimes}.exports \subseteq \textsf{GetPage} \land \textsf{NYTimes}.invokes \subseteq \textsf{SendPage}$

$\textsf{GetPage}.args(\textsf{``link''}) \in \textsf{Link} \land \textsf{GetPage}.args(\textsf{``currCounter''}) \in \textsf{Counter}$

$\textsf{NYTimes}.stores(\textsf{``articles''}) \in \textsf{Map[Link,Article]}$ 

$\textsf{NYTimes}.cons = \{(\textsf{GetPage},f_1),
(\textsf{SendPage}, f_2)\}$ where

$f_1 \equiv \forall o \in \textsf{GetPage} \cdot o.args(\textsf{currCounter}) \leq \textsf{LIMIT}$

$f_2 \equiv \exists o' \in \textsf{GetPage} \cdot o.args(\textsf{page}) =
(\textsf{NYTimes}.stores(\textsf{articles}))[o'.args(\textsf{link})]
\land$ 

$\quad\quad\quad\quad\quad\quad\quad\quad\quad o.args(\textsf{newCounter}) = o'.args(\textsf{currCounter}) + 1$

\end{minipage}
}
\end{figure}

% \begin{figure}[!t]
% \fbox{
% \begin{minipage}[t]{0.95\textwidth}
% $\textsf{Paywall}.comps = \{\textsf{NYTimes}, \textsf{Client},
% \textsf{Reader}\}$ 

% $\textsf{Paywall}.data = \textsf{Article} \cup \textsf{Link} \cup
% \textsf{Counter}$ 

% $\textsf{NYTimes}.exports \subseteq \textsf{GetPage}$ 

% $\textsf{GetPage}.args =
% \{(\textsf{``link''}, \textsf{Link}),(\textsf{``currCounter''}, \textsf{Counter})\}$

% $\textsf{NYTimes}.invokes \subseteq \textsf{SendPage}$

% $\textsf{NYTimes}.stores =
% \{\textsf{(\textsf{``articles''}, \textsf{Map[Link,Article]})}\}$ 

% $\textsf{NYTimes}.cons = \{(\textsf{GetPage},f_1),
% (\textsf{SendPage}, f_2)\}$ where

% $f_1 \equiv \forall o \in \textsf{GetPage} \cdot o.args(\textsf{currCounter}) \leq \textsf{LIMIT}$

% $f_2 \equiv \exists o' \in \textsf{GetPage} \cdot o.args(\textsf{page}) =
% (\textsf{NYTimes}.stores(\textsf{articles}))[o'.args(\textsf{link})]
% \land$ 

% $\quad\quad\quad\quad\quad\quad\quad\quad\quad o.args(\textsf{newCounter}) = o'.args(\textsf{currCounter}) + 1$

% \end{minipage}
% }
% \end{figure}

Each operation $o \in O$ \fix{is associated with}{has} zero or more
named \textit{arguments}\fix{, which the invoker uses to transmit data
  to its exporter}{; a component invoking an operation transmits data to
  the component exporting that operation by setting the operation's
  arguments}. For example, every operation $o$ of type
$\textsf{GetPage}$ carries two arguments: a link to an article
($\textsf{link}$), and a counter ($\textsf{currCounter}$) that
represents the number of articles accessed; i.e.,
\begin{align*}
  &dom(o.args) = \{ \textsf{link}, \textsf{currCounter} \} \\
  &o.args(\textsf{link}) \in \textsf{Link} \land
  o.args(\textsf{currCounter}) \in \textsf{Int}
\end{align*}
\am{replace with? (it doesn't require additional syntax, like \textit{dom} and it's more succinct)}
\begin{align*}
  \textsf{GetPage}.args = \{ ``link" \pfun \textsf{Link}, ``currCounter" \pfun \textsf{Int} \}
\end{align*}

Finally, a system model $m \in M$ is simply defined as a set of components
($m.comps$) and data types ($m.data$). 

\paragraph{\textbf{Behavior}} A component may not allow every incoming
operation, and may not send out arbitrary messages to other
components. For every type of operation that it exports, the component can
impose a constraint on the set of the operations that it is willing to
accept; the function $cons$ is used to specify such a constraint. For
example, \textsf{NYTimes} may only accept an incoming request for an
article only if \textsf{currCounter} provided with the request does
not exceed the limit. Formally, for each operation $o$ of type
\textsf{GetPage}, $\textsf{NYTimes}.cons(o)$ returns a formula $f$
such that
\begin{align*}
f \equiv o.args(\textsf{currCounter}) \leq \textsf{LIMIT}
\end{align*}
where $\textsf{LIMIT}$ is a constant that represents the number of
allowed articles.

Similarly, a component may impose a constraint on the set of operations
that it can send out. For example, the authorization server may invoke
\textsf{SendPage} on the client only if it has already received and
accepted a valid \textsf{GetPage} message. In addition,
\textsf{SendPage} must include, as arguments, an article that
corresponds to the requested link, and an increment of the current
counter. Formally, for every $o \in c.invokes \cap \textsf{SendPage}$,
$\textsf{NYTimes}.cons(o)$ returns formula $f$ such that:
\begin{align*}
f \equiv \exists o' \in \textsf{GetPage} \cdot & o.args(\textsf{page}) =
(\textsf{NYTimes}.stores(\textsf{articles}))[o'.args(\textsf{link})]
\land \\
& o.args(\textsf{newCounter}) = o'.args(\textsf{currCounter}) + 1
\end{align*}

In effect, constraints in $cons$ are being used to
declaratively specify the behavior of a component in terms of input and
output operations that it is allowed to perform. The overall behavior
of component $m$ is characterized by sets $c.in$ and $c.out$:
\begin{align*}
c.in = \{ o \in c.exports \;|\; \bigwedge c.cons(o) \} \\
c.out = \{ o \in c.invokes \;|\; \bigwedge c.cons(o) \}
\end{align*}
Intuitively, $c.in$ represents the set of incoming operations that $m$
accepts, and $c.out$ represents the set of invocations that $m$ is
allowed to make. Note that the domain of $c.cons$ is restricted to
the set of operations that $m$ exports or invokes (i.e., $c.exports
\cup c.invokes$). We assume that if the analyst does not specify a
constraint for an operation that it exports or invokes,
then it is assigned truth value $\top$ (i.e., the operation is always
allowed).

%\input{paywall-formal.tex}
