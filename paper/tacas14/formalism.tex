\section{Modeling Formalism}
\label{sec-formalism}

% Before describing how we reconcile the types of mismatch that we
% discussed in Section~\ref{sec-mismatch}, we first introduce the
% underlying formalism that is used for specifying systems, attacks, and
% security properties.
In this section, we describe, using a standard first-order logic, the
underlying formalism that our framework uses to specify a system and
its behavior. 

\paragraph{\textbf{Structure}} Figure~\ref{fig-formalism} summarizes
the basic constructs of our formalism. A system consists of a set of
\textit{components} $C$ that asynchronously communicate with each
other through \textit{operations} $O$. Each component \textit{exports} zero or
more operations at its interface, and \textit{stores} a set of
\textit{data} $D$. A piece of data $d \in D$ flows from component $c1$
to another component $c2$ when $c1$ \textit{invokes} $c2$'s operation
$o$ that includes $d$ as one of its \textit{arguments}. 

For example, consider a snippet of the New York Times paywall
model\footnote{For convenience, we use the dot (.)  notation to refer
  a field element by name; for example, $c.exports$ refers to the
  $exports$ field of component $c$.} in
Figure~\ref{fig-nytimes-spec}. Component \txtcname{NYTimes} accepts
incoming requests for an article through \txtcname{GetPage}, which
carries two named arguments: a link to an article (\txtstrlit{link})
and a counter that represents the number of articles accessed so far
(\txtstrlit{currCounter}). \txtcname{NYTimes} responds to to
\txtcname{Client} by invoking the latter's \txtcname{SendPage}
operation, which carries the requested article and a new counter to be
stored inside the browser. 

\suppress{this enables our system to accurately track data flows and
  automatically check standard information flow properties such as
  \textit{integrity} and \textit{confidentiality}.}

\def\fsep{\;}
\def\bigsep{\quad\quad\quad\quad\;\;\:}

\begin{figure}[!t]
\scriptsize
\fbox{
\begin{minipage}[t]{0.97\textwidth}
\begin{minipage}[t]{0.455\textwidth}
\begin{tabular}{@{\quad}ll@{\;\;}l}
\multicolumn{3}{l}{\textbf{Sorts}} \\
$C, O, D, M$  &                  & \\
$N, F$        &                  & \mcom{Name, Formula}\\
\\
\multicolumn{2}{l}{\textbf{Model} ($M$)} \\
$comps$ & $:\fsep \mathcal P (C)$  & \mcom{components} \\
$data$  & $:\fsep \mathcal P (D)$  & \mcom{data sets}\\
\end{tabular}
\end{minipage}
\quad
\begin{minipage}[t]{0.455\textwidth}
\begin{tabular}{@{\quad}ll@{\;\;}l}
\multicolumn{3}{l}{\textbf{Component} ($C$)} \\
$exports$ & $:\fsep \mathcal P (O)$         & \mcom{exported operations}\\
$invokes$ & $:\fsep \mathcal P (O)$         & \mcom{invoked operations}\\
$stores$  & $:\fsep N \pfun \mathcal P (D)$ & \mcom{stored data}\\
$guards$   & $:\fsep O \pfun F$              & \mcom{guards on ops}\\
\multicolumn{3}{l}{\textbf{Operation} ($O$)} \\
$args$    & $:\fsep N \pfun \mathcal P (D)$ & \mcom{operation arguments}\\
\end{tabular}
\end{minipage}
\end{minipage}
}
\fbox{
\begin{minipage}[t]{0.97\textwidth}
\begin{tabular}{@{\quad}r@{\;}l}
  \multicolumn{2}{l}{\textbf{Auxiliary Functions} (where $c \in C$)} \\
  $incoming(c)$ & $= {\{ o \in c.exports \;|\; c.guard(o) \}}$ \\
  $canAccess(c)$ & $= \{ d \in D \;|\; d \in ran(c.stores) \;\lor \exists o \in incoming(c) \bullet d \in ran(o.args)\} $ \\
  $outgoing(c)$ & $= {\{ o \in c.invokes \;|\; c.guards(o) \land ran(o.args) \subseteq
    canAccess(c)\}}$ \\
\end{tabular}
\end{minipage}
}
\caption{Basic constructs of our modeling formalism. $ran$ returns the
  range of a function.}
\label{fig-formalism}
\end{figure}

\begin{figure}[!t]
  \scriptsize
\fbox{
\begin{minipage}[t]{.97\textwidth}
\begin{minipage}[t]{.3\textwidth}
  \mcom{\cname{Paywall} model} \\
  \begin{tabular}{ll}
    $\cname{Paywall}.comps$ &$= \{\cname{NYTimes}, \cname{Client}, \cname{Reader}\}$\\
%      $\cname{Paywall}.comps$ &$= \cname{NYTimes} \cup \cname{Client} \cup \cname{Reader}$\\
    $\cname{Paywall}.data$  &$= \cname{Article} \cup \cname{Link} \cup \cname{Counter}$ 
  \end{tabular}
  \mcom{operations and behavior}
\end{minipage}%
\hfill%
\begin{minipage}[t]{.51\textwidth}
  \mcom{\textsf{NYTimes} component}\\
  \begin{tabular}{ll}
    $\cname{NYTimes}.exports$ & $= \cname{GetPage}$ \\
    $\cname{NYTimes}.invokes$ & $= \cname{SendPage}$ \\
    $\cname{NYTimes}.stores$  & $= \{\cname{(\strlit{articles}, \cname{Map[Link,Article]})}\}$
  \end{tabular}
\end{minipage}
\begin{tabular}{ll}
$\cname{GetPage}.args$  & $= \{(\strlit{link}, \cname{Link}),(\strlit{currCounter}, \cname{Counter})\}$ \\
$\cname{SendPage}.args$ & $= \{(\strlit{page}, \cname{Article}),(\strlit{newCounter}, \cname{Counter})\}$\\
\end{tabular}
\\
\begin{tabular}{ll}
$\cname{NYTimes}.guard(\cname{GetPage}) $  & $= f_1(o) \equiv o.args(\strlit{currCounter}) \leq \cname{LIMIT}$\\
$\cname{NYTimes}.guard(\cname{SendPage}) $ & $= f_2(o) \equiv \exists t \in \cname{GetPage} \;\;\bullet $\\
 & \bigsep $ o.args(\strlit{page}) = \cname{NYTimes}.stores(\strlit{articles})[t.args(\strlit{link})] \;\land $ \\
 & \bigsep $ o.args(\strlit{newCounter}) = t.args(\strlit{currCounter}) + 1$
\end{tabular}
\end{minipage}
}
%% keep above or below
% \fbox{
% \begin{minipage}[t]{0.97\textwidth}
% \mcom{definition of the \cname{Paywall} model}

% $\cname{Paywall}.comps = \{\cname{NYTimes}, \cname{Client},
% \cname{Reader}\}, \cname{Paywall}.data = \cname{Article} \cup \cname{Link} \cup
% \cname{Counter}$ 

% \mcom{operations for \textsf{NYTimes}}

% $\cname{NYTimes}.exports = \cname{GetPage}, \cname{NYTimes}.invokes = \cname{SendPage}$

% $\cname{GetPage}.args =
% \{(\strlit{link}, \cname{Link}),(\strlit{currCounter}, \cname{Counter})\}$

% $\cname{SendPage}.args =
% \{(\strlit{page}, \cname{Article}),(\strlit{newCounter}, \cname{Counter})\}$

% $\cname{NYTimes}.stores =
% \{\cname{(\strlit{articles}, \cname{Map[Link,Article]})}\}$ 

% \mcom{behavior of \cname{NYTimes} with respect to its operations}

% $\forall o \in \cname{GetPage} \bullet \cname{NYTimes}.guards(o) = f_1 $
% where $f_1 \equiv o.args(\strlit{currCounter}) \leq \cname{LIMIT}$

% $\forall o \in \cname{SendPage} \bullet \cname{NYTimes}.guards(o) = f_2
% $ where

% $\quad f_2 \equiv \exists t \in \cname{GetPage} \bullet t.args(\strlit{page}) =
% \cname{NYTimes}.stores(\strlit{articles})[t.args(\strlit{link})]
% \land$ 

% $\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad o.args(\strlit{newCounter}) = t.args(\strlit{currCounter}) + 1$
% \end{minipage}
% }
\caption{A snippet of the New York Times paywall model. Assume that
  \cname{Map[K, V]} is a predefined data type that represents a map
  from \cname{K} to \cname{V}; $m[k]$ returns the value stored in
  map $m$ at key $k$.}
\label{fig-nytimes-spec}
\end{figure}

Finally, a system model $m \in M$ is
simply defined as a set of components ($comps$) and data sets
($data$). 

\paragraph{\textbf{Behavior}} A component may not allow every incoming
operation, and may not send out arbitrary messages to other
components. For every instance of operation that it exports, the
component can impose a \textit{guard} constraint on the set of the
operations that it is willing to accept. For example, as defined in
Figure~\ref{fig-nytimes-spec}, \txtcname{NYTimes} only accepts a request
for an article only if \txtcname{currCounter} provided with the request
does not exceed the limit.

Similarly, a component may define a guard to restrict operations that
it can invoke, or impose a constraint on arguments that are carried
along with the invoked operations. For example, \txtcname{NYTimes} may
invoke \txtcname{SendPage} on the client only if it has already received
and accepted a valid \txtcname{GetPage} message. In addition,
\txtcname{SendPage} must include, as arguments, an article that
corresponds to the requested link, and an increment of the current
counter.  In effect, guard constraints are used to
declaratively specify the behavior of a component in terms of input
and output operations that it is allowed to perform.

The overall behavior of component $c$ is characterized by
$incoming(c)$ and $outgoing(c)$. Intuitively, $incoming(c)$ represents
the subset of incoming operations that are deemed valid and accepted
by $c$. Members of $incoming(c)$, in turn, determine the set of data
that $c$ can access; namely, $c$ can access a piece of data $d$ if and
only if $c$ already stores $d$, or $d$ flows into $c$ as part of a
valid incoming operation. Finally, $outgoing(c)$ represents the set of
invocations that $c$ is allowed to make; note that the arguments of $o
\in outgoing(c)$ are restricted to only those data elements that $c$
can access.

\paragraph{\textbf{Properties}} A desirable property about the system
can be expressed in terms of $incoming$, $outgoing$, and
$canAccess$. For example, the property for the paywall example can be
written as
\begin{align*}
\# canAccess(\cname{Reader}) \leq \cname{LIMIT}
\end{align*}
where $\# S$ returns the cardinality of set S. An ensuing analysis
would then attempt to check whether the guards specified in the
components are strong enough to establish the property, and if not,
produce an instance of $canAccess$ that contradicts the above
constraint. 

%\input{paywall-formal.tex}
