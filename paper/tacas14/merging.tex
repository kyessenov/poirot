
\section{Technique for Merging Models}
\label{sec-merging}

In this section, we describe a technique for merging two potentially
mistmached models that describe different aspects of a system. The
merging process is two-fold. First, the analyst specifies the
relationship between two models as a mapping between different
entities in them. Then, given this mapping, we apply an algorithm to
produce a merged model with potentially new behaviors that arise
from the interaction of the components from the previously separate
models.

\subsection{Specifying Relationships between Models}
\label{sec-relationship}

To resolve potential mismatch between two models, the analyst may
specify a relationship between a pair of components, operations, or data
elements. Our notion of a relationship between two entities is that of
a \textit{subset} relation. Informally, two entities are related if
they both describe the same concept in the real world, but one is a
generic representation of the other. \ek{For example,
\txtcname{NYTimes} can be regarded as a specialized kind of
\txtcname{HTTPServer} with the role of controlling access to articles
that it stores.  A similar kind of relationship can be introduced
between operations or data elements. Operation \txtcname{GetPage},
implemented using a generic HTTP request, can be regarded as a kind of
\txtcname{GET} operation. Similarly, since a counter is stored as a
cookie, \txtcname{Counter} can be treated as a kind of \txtcname{Cookie}.}

\begin{defn} A relationship $r \in R$ between two models is a tuple
  $(r_{C}, r_{O}, r_{D})$ where $r_{C} \subseteq C \times C$, $r_{O}
  \subseteq \mathcal P (O) \times \mathcal P (O)$, and $r_{D}
  \subseteq \mathcal P (D) \times \mathcal P (D)$ represent subset
  relations between a pair of components, operation sets, and data
  sets, respectively.
\end{defn}
For example, to merge the paywall and cookie replay models from
Figure~\ref{fig-nytimes}, Alice may specify the following
relationships between the two models:
\begin{scriptsize}
\begin{align*}
  r_{C} = \{&(\textsf{Client$,$ Browser}),(\textsf{NYTimes$,$
    HTTPServer}), (\textsf{Reader$,$
    WebUser})\} \\
  r_{O} = \{&(\textsf{GetPage$,$ GET}), (\textsf{GET$,$ GetPage}),
  (\textsf{SendPage$,$
    Resp})\}\\
  r_{D} = \{&(\textsf{Article$,$ HTML}),(\textsf{Link$,$ URL}),
  (\textsf{Counter$,$ Cookie})\}
\end{align*}
\end{scriptsize}
A subset relation is asymmetrical, and so two entities can be
specified as equivalent by including a tuple and its inverse in the
same relation; for example, $r_{O}$ here specifies that
\txtcname{GetPage} operations are the only kind of \txtcname{GET}
operations that will be exported by \txtcname{NYTimes} running on top of
a HTTP server.

% Intuitively, these relationships correspond to the system designer's
% decisions about how components, operations, and data are to be realized
% and implemented. By varying these relationships, the designer can
% explore the security implications of different design decisions. For
% example, in another variation of OAuth, the designer may decide to
% deploy \txtcname{Client} as a server-side application instead of a
% client-side application running on the top of a browser; in this
% case,\txtcname{Client} and \txtcname{TrustedServer} would be specified as
% an entry in $r_{M}$. As a consequence of this relationship,
% \txtcname{Client} would inherit the characteristics of
% \txtcname{TrustedServer}, and now be susceptible to server-side attacks
% instead of browser-based ones.

\begin{algorithm}[!t]
\begin{algorithmic}[1]
\Function{MergeModels}{$m1, m2, r$}
\Let{$h$}{\textsf{BuildMapping}($m1$, $m2$, $r$)}
\Let{$m'$}{\textsf{BuildModel}($m1$, $m2$, $h$)}
%\Let{$m'$}{\textsf{Substitute}}($m'$, $h$)
\State \Return{$m'$}
\EndFunction

\item[]
\Function{BuildMapping}{$m1, m2, (r_{C}, r_{O}, r_{D})$}
\ForAll{$(D1, D2) \in r_{D}$}
\Let{$h_{D}(D1)$}{\textsf{MergeData}($D1$, $D2$)}
\EndFor
\ForAll{$(m1, m2) \in r_{C}$}
\Let{$h_{C}(m1), h_{C}(m2)$}{\textsf{MergeComp}($m1$, $m2$, $r_{O}$)}
\EndFor
\State \Return{$(h_{C}, h_{D})$}
\EndFunction

\item[]
\Function{BuildModel}{$m1, m2, (h_{C}, h_{D})$}
\Let{$C', D'$}{$\varnothing$}
\ForAll{$m \in m1.components \cup m2.components$}
\If{$m \in dom(h_{C})$}
\Let{$C'$}{$C' \cup \{h_{C}(m)\}$}
\Else
\Let{$C'$}{$C' \cup \{m\}$}
\EndIf
\EndFor
\ForAll{$ds \subseteq m1.data \cup m2.data$}
\If{$ds \in dom(h_{D})$}
\Let{$D'$}{$D' \cup h_{D}(ds)$}
\Else
\Let{$D'$}{$D' \cup ds$}
\EndIf
\EndFor
\State \Return{$(C',D')$}
\EndFunction

\item[]
\Function{MergeData}{$D1, D2$}
\Let{$D'$}{$\{d2 \in D2\; |\; \exists d1 \in D1 \cdot d2 =
  f_{D1,D2}(d1)\}$}
\ForAll{$d \in D1$}
\Let{$f_{D1,D2}(d).fields$}{$f_{D1,D2}(d).fields \cup d.fields$}
\EndFor
\State \Return{$D'$}
\EndFunction

\item[]
\Function{MergeComp}{$m1, m2, r_{O}$}
\Let{$e, i$}{$m2.exports, m2.invokes$}
\Let{$s, c$}{$m1.stores \cup m2.stores, m1.guard \cup m2.guard$}
\ForAll{$(O1, O2) \subseteq m1.exports \times m2.exports$}
\If{$(O1, O2) \in r_{O}$}
\Let{$e$}{$e \cup \textsf{MergeOp}(O1, O2)$}
\Else
\Let{$e$}{$e \cup O1$}
\EndIf
\EndFor
\ForAll{$(O1, O2) \subseteq m1.invokes \times m2.invokes$}
\If{$(O1, O2) \in r_{O}$}
\Let{$i$}{$i \cup \textsf{MergeOp}(O1, O2)$}
\Else
\Let{$i$}{$i \cup O1$}
\EndIf
\EndFor
\Let{$m'$}{$(e,i,s,c)$}
\State \Return{$m'$}
\EndFunction

\item[]
\Function{MergeOp}{$O1, O2$}
\Let{$O'$}{$\{o2 \in O2\; |\; \exists o1 \in O1 \cdot o2 =
  f_{O1,O2}(o1)\}$}
\ForAll{$o \in O1$}
\Let{$f_{O1,O2}(o).args$}{$f_{O1,O2}(o).args \cup o.args$}
\EndFor
\State \Return{$O'$}
\EndFunction

% \item[]
% \Function{Substitute}{$v, (h_{m}, h_{D})$}
% \State ... // Omitted
% \State \Return{$v$}
% \EndFunction
\end{algorithmic}
\caption{Merging Models}
\label{alg-merge-models}
\end{algorithm}

\subsection{Merging Algorithm}

The algorithm for merging, shown in Algorithm~\ref{alg-merge-models},
accepts two models, $m1, m2 \in M$, and a relationship $r \in R$
between them, and produces a new model, $m' \in M$. The algorithm is
divided into two steps. First, for every pair of entities $e1$ and
$e2$ specified in $r$, it merges them into a single entity $e'$ that is a
subset of $e2$ and corresponds to $e1$ (Line 2). Then, the algorithm
builds a new model by replacing every $e1$ in $r$ with $e'$ (Line 3).

% \begin{figure*}[!t]
% \centering
% \includegraphics[width=0.95\textwidth]{diagrams/oauth-csrf-merged}
% \caption{Result of Merging the OAuth and CSRF models from Figure~\ref{fig-oauth}.}
% \label{fig-merged-oauth-csrf}
% \end{figure*}

\subsubsection{Step 1: Merging Related Entities}

Procedure \txtcname{BuildMapping} performs the task of merging indivudal
entities in two-fold, first merging each pair of related data sets
(Line 7), and then merging the related components (Line 9). As it
merges these entities, \txtcname{BuildMapping} incrementally builds a
pair of functions ($h_{C}$ and $h_{D}$) that map the original
components and data sets from $r$ to their merged counterparts.

% \begin{figure}[!t]
% \centering
% \includegraphics[width=0.40\textwidth]{diagrams/embedding}
% \caption{Embedding of \textsf{Token} into \textsf{String}}
% \label{fig-embedding}
% \end{figure}

\paragraph{\textbf{Merging Data}} For each pair of data sets $(D1,
D2)$ in $r_{D}$, \txtcname{MergeData} produces a new set of data, $D'$,
that replaces $D1$ in the merged model $m'$, and can still be treated
like instances of $D2$. 

For example, given $(\txtcname{Article}, \txtcname{HTML}) \in r_{D}$,
\txtcname{MergedData} produces a new data set
$\txtcname{Article}_{\textsf{HTML}}$, which conceptually represents the
encodings of the New York Times articles in HTML
format. $\txtcname{Article}$ and $\txtcname{Article}_{\textsf{HTML}}$ are
isomorphic; for every $a \in \txtcname{Article}$, $m'$ contains a unique
$a' \in \txtcname{Article}_{\textsf{HTML}}$ such that $a'$ represents an
HTML encoding of $a$. Note that $m'$ may contain some HTML documents
that do not correspond to any article (i.e.,
$\txtcname{Article}_{\textsf{HTML}}$ may be a strict subset of $\txtcname{HTML}$).

Formally, $D'$ represents the result of \textit{embedding} $D1$ into
$D2$.
\begin{defn} An embedding from set $A$ to $B$ is an injective function
  $f : A \rightarrow B$.
\end{defn}
The embedding establishes a subset relation between $D1$ and $D2$ by
ensuring that every element $d$ of $D1$ has a unique counterpart
$f(d)$ that is a member of $D2$. For example, the embedding from
\txtcname{Article} to \txtcname{HTML} is a function $f$ that maps each
article to its HTML counterpart. Then, in the merged model $m'$, every
$a \in \txtcname{Article}$ can be replaced by $f(a)$ without
invalidating existing references to $\txtcname{Article}$ in $m1$.

\begin{thm} For every $D1, D2 \subseteq D$, there always exists a
  function $f : D1 \rightarrow D2$ such that f is an embedding from
  $D1$ to $D2$.
\end{thm}
\todo{need proof here}
% \begin{proof} Omitted.
% \end{proof}

Finally, the set of fields associated with $D'$ is constructed as the
union of fields in $D1$ and $D2$. 

\paragraph{\textbf{Merging Components}} Given a pair of components $(m1, m2)
\in r_{C}$, along with pairs of related operations $r_{O}$,
\txtcname{MergeComp} produces a new component $m'$ behaves like $m1$
while also obtaining the characteristics of $m2$.

The behaviors of the two components may be related through one or more
pairs of operations specified in $r_{O}$. If $m1$ exports or invokes
a set of operations $O1$ that are related to another set of operations
$O2$ in $m2$, \txtcname{MergeComp} merges the two sets by using the
procedure \txtcname{MergeOp} (lines 34 and 39). 

\paragraph{\textbf{Merging Operations}} Operations are merged in the
similar fashion as the data elements; an embedding is used to
establish a subset relation between $O1$ and $O2$, resulting in a new
set of operations $O' \subseteq O2$, which also inheirts all of the
arguments from $O1$ and $O2$ (Line 47).

For example, given $(\txtcname{SendPage}, \txtcname{Resp}) \in r_{O}$,
$MergeOp$ produces $\txtcname{SendPage}_{\textsf{Resp}}$, which
represents the implementation of \txtcname{SendPage} as a standard HTTP
response.  $\txtcname{SendPage}_{\textsf{Resp}}$ can be used by
\txtcname{NYTimes} to send an article back to
$\txtcname{Client}_\textsf{Browser}$, but is also treated like any
standard HTTP response. Note that $\txtcname{Client}_\textsf{Browser}$
may receive other kinds of HTTP responses besides the ones that carry
an article from \txtcname{NYTimes}; i.e., there may exist $r \in
\txtcname{Resp}$ that is not a member of $\txtcname{SendPage}_{\textsf{Resp}}$.

The guard function of the merged component $m'$ is constructed
as the union of $m1.guard$ and $m2.guard$ (Line 31). This ensures that $m'$
maintains the behaviors of both $m1$ and $m2$ with respect to the
operations that they export and invoke, including the merged
operations. In particular, the set of constraints applicable to $o' \in O' =
MergeOp(O1, O2)$ can be characterized as follows:
\begin{align*}
m'.guard(o') = \{& l \in F \;|\; l \in m2.guard(o') \; \lor \\
&\exists o1 \in O1 
\cdot o' = f_{O1, O2}(o1) \land l \in m1.guard(o1) \} 
\end{align*}
In other words, since $o'$ can be considered a member of both $O1$ and
$O2$, $o'$ retains all of the constraints that $m1$ and $m2$ impose
on $O1$ and $O2$, respectively. Similarly, the set of data that $m'$
stores is constructed as the union of $m1.stores$ and $m2.stores$ (Line 31).

\todo{example with invokes constraints on SendResp}

\todo{Explain why Alice specified GET and GetPage to be equivalent}

\paragraph{\textbf{Remarks}} Note that the merging algorithm
does not enforce any constraint between the arguments of two
operations being merged, or the fields of two data sets. \todo{Say
this was intentionally done to make the mapping lightweight}

% To be more precise about what it means for a component to behave like
% another, we use the notion of observational refinement that we
% introduced earlier:
% \begin{thm}
% \label{thm-refinement}
% Given $r \in R$ and $(m1, m2) \in r_{M}$, let $m' = MergeComp(m1,
% m2, r_{O})$. Then, $m'$
% is an observation refinement of both $m1$ and $m2$.
% \end{thm}
% \begin{proof}
%   By construction, for every operation $o \in O$ in $m'$ that
%   originated from $m1$, $m'$ retains all of the constraints on $o$
%   from $m1$ (i.e., $m1.cons(o) \subseteq m'.cons(o)$). Thus, $m'.in$
%   and $m'.out$ are subsets of $m1.in$, and $m1.out$, respectively,
%   satisfying the conditions for an observational refinement of $m1$ by
%   $m'$.  Similarly, since $m'$ retains all of the constraints on every
%   operation that it inherits from $m2$, $m'$ is an observational
%   refinement of $m2$.
% \end{proof}
% The key intuition behind the proof is that the merging operation only
% restricts the behaviors of the components on merged operations, and
% retains the same behaviors for all other operations. For example, from
% \txtcname{Client}'s perspective, the merged component
% $\txtcname{AuthorizationServer}_\textsf{TS}$ still behaves like
% \txtcname{AuthorizationServer}, receiving
% requests and sending back an access token only if a valid credential
% is provided.

\subsubsection{Step 2: Building a New Model}

Once the different parts of the models have been merged according to
the given relationships, constructing the merged model is a
straightforward process. Using the function $h_{C}$ that maps a component
from an existing component to its merged counterpart, \txtcname{BuildModel}
simply replaces each of the components that appear in $r_{C}$ with the
new merged one (Line 15), while leaving those that do not appear in
$r_{C}$ intact (Line 17). Similarly, \txtcname{BuildModel} uses $h_{D}$
to replace each of the data sets from $m1$ that appears in $r_{D}$
with its embedded counterpart (Line 20).  

\subsection{Implications of Merging}

Merging two models introduces a new set of behaviors into
the original model of the system, some of which may lead a violation
of a property that prior analyses might have ruled out. We categorize
different types of interactions that arises as a result of
merging. Let $C_1, C_2 \in C$ be components from models $M_1$ and
$M_2$, $D_1, D_2 \subseteq D$ be data sets from $M_1$ and $M_2$, and
$O_1, O_2 \subseteq O$ be the sets of operations that $C_1$ and $C_2$
exports, respectively. 

\textbf{A merged component exports additional operations}. Let $C'$ be
the result of merging $C_1$ with $C_2$. Then, $C'$ exports operations
$O_2$ (which are absent from $M_1$), introducing new interactions
between $C_1$ and the invokers of $O_2$ in $M_2$. 

For example, $\txtcname{Client}_\textsf{Browser}$ exports two additional
operations, \txtcname{ExtractCookie} and \txtcname{SetCookie}, that are
invoked by $\txtcname{Reader}_\textsf{WebUser}$.

\textbf{A merged operation is invoked by additional components}. Let $O'$
be the result of embedding $O_1$ into $O_2$. Then, $O'$ may be invoked
by all components in $M_2$ that invoke $O_2$, introducing new interactions
between $C_1$ and the invokers of $O_2$ in $M_2$.

\textbf{A merged data is included as arguments in additional
  operations.}  Let $D'$ be the result of embedding $D_1$ into
$D_2$. Then, for some $O_2$ that expects an argument $a \in D_2$,
a member of $D'$ may also be substituted for $a$, introducing new
flows of data $D_1$ to the exporters of $O_2$ in $M_2$.

Since $\txtcname{Counter}_\textsf{Cookie}$ is now a
subset of $\txtcname{Cookie}$, a counter can be provided as the $cookie$
argument in $ExtractCookie$.

% One
% consequence of the merging is that there are new interactions among
% components that did not exist before. For example, the malicious server
% now interacts with the client application by receiving and sending
% HTTP messages.

% Figure~\ref{fig-merged-oauth-csrf} shows the result of merging the
% OAuth and CSRF models from Figure~\ref{fig-oauth} according to the
% relationships that we specified in Section~\ref{sec-relationship}.
% One example of a CSRF attack against OAuth, made possible due to new
% interactions in the merged model, is as follows. The goal of the
% attacker is to trick the resource owner into granting more resources
% to the client than would be normally desirable by him or her (for
% example, granting write access to the entire Facebook profile, instead
% of just read access). The attack begins when
% $\txtcname{ResourceOwner}_\textsf{EndUser}$ visits a URI that is owned
% by \txtcname{MraliciousServer}, which, then crafts a DOM that is designed
% to force $\txtcname{Client}_\textsf{B}$ into sending
% $\txtcname{reqAccessToken}_\textsf{hreq}$ to
% $\txtcname{AuthorizationServer}_\textsf{TS}$. In particular, this
% request is constructed so that it includes, for argument
% $\txtcname{resID}$, some $\txtcname{badResID}$ $\in$ $\txtcname{ResourceID}$
% that identifies the resource that the attacker wishes to access.

% $\txtcname{Client}_\textsf{B}$, having inherited the behavior of
% \txtcname{Browser}, includes any associated cookies as part of the
% request headers. Since a cookie can be used as a credential,
% $\txtcname{AuthorizationServer}_\textsf{TS}$ accepts this request to be
% valid, and sends back the access token that corresponds to
% $\txtcname{badResID}$, giving $\txtcname{Client}_\textsf{B}$ full access
% to the resource. Note that the attacker was able to bypass the usual
% interactions between $\txtcname{Client}_\textsf{B}$ and
% $\txtcname{ResourceOwner}_\textsf{ES}$ and obtain an access token
% without first gaining permission from the resource owner.
