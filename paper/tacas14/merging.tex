
\section{Technique for Merging Models}
\label{sec-merging}

In this section, we describe a technique for merging two potentially
mistmached models that describe different aspects of a system. The
merging process is two-fold. First, the analyst specifies the
relationship between two models as a mapping between different
entities in them. Then, given this mapping, we apply an algorithm to
produce a merged model with potentially new behaviors that arise
from the interaction of the components from the previously separate
models.

\subsection{Specifying Relationships between Models}
\label{sec-relationship}

To resolve potential mismatch between two models, the analyst may
specify a relationship between a pair of components, operations, or data
elements. Our notion of a relationship between two entities is that of
a \textit{subset} relation. Informally, two entities are related if
they both describe the same concept in the real world, but one is a
generic representation of the other. \ek{For example,
\txtcname{NYTimes} can be regarded as a specialized kind of
\txtcname{HTTPServer} with the role of controlling access to articles
that it stores.  A similar kind of relationship can be introduced
between operations or data elements. Operation \txtcname{GetPage},
implemented using a generic HTTP request, can be regarded as a kind of
\txtcname{GET} operation. Similarly, since a counter is stored as a
cookie, \txtcname{Counter} can be treated as a kind of \txtcname{Cookie}.}

\begin{defn} A relationship $r \in R$ between two models is a tuple
  $(r_{C}, r_{O}, r_{D})$ where $r_{C} \subseteq C \times C$, $r_{O}
  \subseteq \mathcal P (O) \times \mathcal P (O)$, and $r_{D}
  \subseteq \mathcal P (D) \times \mathcal P (D)$ represent subset
  relations between a pair of components, operation sets, and data
  sets, respectively.
\end{defn}
For example, to merge the paywall and cookie replay models from
Figure~\ref{fig-nytimes}, Alice may specify the following
relationships between the two models:
\begin{scriptsize}
\begin{align*}
  r_{C} = \{&(\txtcname{Client$,$ Browser}),(\txtcname{NYTimes$,$
    HTTPServer}), (\txtcname{Reader$,$
    WebUser})\} \\
  r_{O} = \{&(\txtcname{GetPage$,$ GET}), (\txtcname{GET$,$ GetPage}),
  (\txtcname{SendPage$,$
    Resp})\}\\
  r_{D} = \{&(\txtcname{Article$,$ HTML}),(\txtcname{Link$,$ URL}),
  (\txtcname{Counter$,$ Cookie})\}
\end{align*}
\end{scriptsize}
A subset relation is asymmetrical, and so two entities can be
specified as equivalent by including a tuple and its inverse in the
same relation; for example, $r_{O}$ here specifies that
\txtcname{GetPage} operations are the only kind of \txtcname{GET}
operations that will be exported by \txtcname{NYTimes} running on top of
a HTTP server.

% Intuitively, these relationships correspond to the system designer's
% decisions about how components, operations, and data are to be realized
% and implemented. By varying these relationships, the designer can
% explore the security implications of different design decisions. For
% example, in another variation of OAuth, the designer may decide to
% deploy \txtcname{Client} as a server-side application instead of a
% client-side application running on the top of a browser; in this
% case,\txtcname{Client} and \txtcname{TrustedServer} would be specified as
% an entry in $r_{M}$. As a consequence of this relationship,
% \txtcname{Client} would inherit the characteristics of
% \txtcname{TrustedServer}, and now be susceptible to server-side attacks
% instead of browser-based ones.

\begin{algorithm}[!t]
\begin{algorithmic}[1]
\Function{MergeModels}{$m_{1}, m_{2}, r$}
\Let{$h$}{\textsf{BuildMapping}($m_{1}$, $m_{2}$, $r$)}
\Let{$m'$}{\textsf{BuildModel}($m_{1}$, $m_{2}$, $h$)}
%\Let{$m'$}{\textsf{Substitute}}($m'$, $h$)
\State \Return{$m'$}
\EndFunction

\item[]
\Function{BuildMapping}{$m_{1}, m_{2}, (r_{C}, r_{O}, r_{D})$}
\ForAll{$(D_{1}, D_{2}) \in r_{D}$}
\Let{$h_{D}(D_{1})$}{\textsf{MergeData}($D_{1}$, $D_{2}$)}
\EndFor
\ForAll{$(c_{1}, c_{2}) \in r_{C}$}
\Let{$h_{C}(c_{1}), h_{C}(c_{2})$}{\textsf{MergeComp}($c_{1}$, $c_{2}$, $r_{O}$)}
\EndFor
\State \Return{$(h_{C}, h_{D})$}
\EndFunction

\item[]
\Function{BuildModel}{$m_{1}, m_{2}, (h_{C}, h_{D})$}
\Let{$C', D'$}{$\varnothing$}
\ForAll{$m \in m_{1}.comps \cup m_{2}.comps$}
\If{$m \in dom(h_{C})$}
\Let{$C'$}{$C' \cup \{h_{C}(m)\}$}
\Else
\Let{$C'$}{$C' \cup \{m\}$}
\EndIf
\EndFor
\ForAll{$ds \subseteq m_{1}.data \cup m_{2}.data$}
\If{$ds \in dom(h_{D})$}
\Let{$D'$}{$D' \cup h_{D}(ds)$}
\Else
\Let{$D'$}{$D' \cup ds$}
\EndIf
\EndFor
\State \Return{$(C',D')$}
\EndFunction

\item[]
\Function{MergeData}{$D_{1}, D_{2}$}
\Let{$f_{D_{1},D_{2}}$}{\textsf{BuildEmbeddingFunc}($D_{1}$, $D_{2}$)}
\Let{$D'$}{$f_{D_{1},D_{2}}(D_{1})$}
\State \Return{$D'$}
\EndFunction

\item[]
\Function{MergeComp}{$c_{1}, c_{2}, r_{O}$}
\Let{$e, i$}{$c_{2}.exports, c_{2}.invokes$}
\Let{$s, g$}{$c_{1}.stores \cup c_{2}.stores, c_{1}.guard \cup c_{2}.guard$}
\ForAll{$(O_{1}, O_{2}) \subseteq c_{1}.exports \times c_{2}.exports$}
\If{$(O_{1}, O_{2}) \in r_{O}$}
\Let{$e$}{$e \cup \textsf{MergeOp}(O_{1}, O_{2})$}
\Else
\Let{$e$}{$e \cup O_{1}$}
\EndIf
\EndFor
\ForAll{$(O_{1}, O_{2}) \subseteq c_{1}.invokes \times c_{2}.invokes$}
\If{$(O_{1}, O_{2}) \in r_{O}$}
\Let{$i$}{$i \cup \textsf{MergeOp}(O_{1}, O_{2})$}
\Else
\Let{$i$}{$i \cup O_{1}$}
\EndIf
\EndFor
\Let{$c'$}{$(e,i,s,g)$}
\State \Return{$c'$}
\EndFunction

\item[]
\Function{MergeOp}{$O_{1}, O_{2}$}
\Let{$f_{O_{1},O_{2}}$}{\textsf{BuildEmbeddingFunc}($O_{1}$, $O_{2}$)}
\Let{$O'$}{$f_{O_{1},O_{2}}(O_{1})$}
\ForAll{$o \in O_{1}$} \Let{$f_{O_{1},O_{2}}(o).args$}{$f_{O_{1},O_{2}}(o).args \cup o.args$}
\EndFor
\State \Return{$O'$}
\EndFunction

% \item[]
% \Function{Substitute}{$v, (h_{m}, h_{D})$}
% \State ... // Omitted
% \State \Return{$v$}
% \EndFunction
\end{algorithmic}
\caption{Merging Models}
\label{alg-merge-models}
\end{algorithm}

\subsection{Merging Algorithm}

The algorithm for merging, shown in Algorithm~\ref{alg-merge-models},
accepts two models, $m_{1}, m_{2} \in M$, and a relationship $r \in R$
between them, and produces a new model, $m' \in M$. The algorithm is
divided into two steps. First, for every pair of entities $e1$ and
$e2$ specified in $r$, it merges them into a single entity $e'$ that is a
subset of $e2$, and corresponds to $e1$ (Line 2). Then, the algorithm
builds a new model by replacing every $e1$ in $r$ with $e'$ (Line 3).

% \begin{figure*}[!t]
% \centering
% \includegraphics[width=0.95\textwidth]{diagrams/oauth-csrf-merged}
% \caption{Result of Merging the OAuth and CSRF models from Figure~\ref{fig-oauth}.}
% \label{fig-merged-oauth-csrf}
% \end{figure*}

\subsubsection{Step 1: Merging Related Entities}

Procedure \txtcname{BuildMapping} performs the task of merging indivudal
entities in two-fold, first merging each pair of related data sets
(Line 7), and then merging the related components (Line
9). As output, \textsf{BuildMapping} returns a pair of functions
($h_{C}$ and $h_{D}$) that map the original components and data sets
from $r$ to their merged counterparts; these functions are then used
in Step 2 to construct a merged model.

% \begin{figure}[!t]
% \centering
% \includegraphics[width=0.40\textwidth]{diagrams/embedding}
% \caption{Embedding of \textsf{Token} into \textsf{String}}
% \label{fig-embedding}
% \end{figure}

\paragraph{\textbf{Merging Data}} For each pair of data sets $(D_{1},
D_{2})$ in $r_{D}$, \textsf{MergeData} produces a new set of data, $D'$,
that replaces $D_{1}$ in the merged model $m'$, and can be treated
like instances of $D_{2}$. 

For example, given $(\txtcname{Article}, \txtcname{HTML}) \in r_{D}$, \txtcname{MergedData} produces a new data set $\txtcname{Article}_{\textsf{HTML}}$, which conceptually represents the encodings of the New York Times articles in HTML format. $\textsf{Article}$ and $\textsf{Article}_{\textsf{HTML}}$ correspond one-to-one; for every $a \in \textsf{Article}$, there exists a unique $a' \in \textsf{Article}_{\textsf{HTML}}$ such that $a'$ represents an HTML encoding of $a$. Note that there may be some HTML documents that do not correspond to any article (i.e., $\textsf{Article}_{\textsf{HTML}}$ is a strict subset of $\textsf{HTML}$).

Formally, $D'$ represents the result of \textit{embedding} $D_{1}$ into
$D_{2}$. Since members of $D_{1}$ and $D_{2}$ are abstract values, we can
construct an injective function $f : D_{1} \rightarrow D_{2}$ by assigning
to each $d_{1} \in D_{1}$ a unique counterpart $d_{2} \in D_{2}$. Then, an
embedding of $D_{1}$ into $D_{2}$ is simply the set $f(D_{1})$. For example,
let $f_{(\textsf{A,H})}$ be an embedding function that maps each
article to its HTML counterpart. Then, every $a \in \textsf{Article}$
in the original model $m_{1}$ can be substituted by
$f_{(\textsf{A,H})}(a)$ in the merged model $m'$.

% \begin{thm} For every $D_{1}, D_{2} \subseteq D$, there always exists a
%   function $f : D_{1} \rightarrow D_{2}$ such that f is an embedding from
%   $D_{1}$ to $D_{2}$.
% \end{thm}
% \todo{need proof here}
% \begin{proof} Omitted.
% \end{proof}

\paragraph{\textbf{Merging Components}} Given a pair of components
$(c_{1}, c_{2}) \in r_{C}$, along with pairs of related operations $r_{O}$,
\textsf{MergeComp} produces a new component $c'$ that combines the
behavior of $c_{1}$ and $c_{2}$.

The behaviors of the two components may be related through one or more
pairs of operations specified in $r_{O}$. If $c_{1}$ exports or invokes
a set of operations $O_{1}$ that are related to another set of operations
$O_{2}$ in $c_{2}$, \textsf{MergeComp} merges the two sets by using the
procedure \textsf{MergeOp}. 


\paragraph{\textbf{Merging Operations}} Operations are merged in the
similar fashion as the data elements; an embedding is used to
establish a subset relation between $O_{1}$ and $O_{2}$, resulting in a new
set of operations $O' \subseteq O_{2}$, which also inheirts all of the
arguments from $O_{1}$ and $O_{2}$ (Line 47).

For example, given $(\txtcname{SendPage}, \txtcname{Resp}) \in r_{O}$,
$MergeOp$ produces $\txtcname{SendPage}_{\textsf{Resp}}$, which
represents the implementation of \txtcname{SendPage} as a standard HTTP
response.  $\txtcname{SendPage}_{\textsf{Resp}}$ can be used by
\txtcname{NYTimes} to send an article back to
$\txtcname{Client}_\textsf{Browser}$, but is also treated like any
standard HTTP response. Note that $\txtcname{Client}_\textsf{Browser}$
may receive other kinds of HTTP responses besides the ones that carry
an article from \txtcname{NYTimes}; i.e., there may exist $r \in
\txtcname{Resp}$ that is not a member of $\txtcname{SendPage}_{\textsf{Resp}}$.

The guard function of the merged component $c'$ is constructed
as the union of $c_{1}.guard$ and $c_{2}.guard$ (Line 30). This ensures that $c'$
maintains the behaviors of both $c_{1}$ and $c_{2}$ with respect to the
operations that they export and invoke, including the merged
operations. To be more precise, the set of constraints applicable to $o' =
MergeOp(O_{1}, O_{2})$ can be characterized as follows:
\begin{align*}
c'.guard(o') = \bigwedge \{& l \in F \;|\; l \in c_{2}.guard(o') \; \lor \\
&\exists o1 \in O_{1} 
\cdot o' = f_{O_{1}, O_{2}}(o1) \land l \in c_{1}.guard(o1) \} 
\end{align*}
In other words, since $o'$ can be considered a member of both $O_{1}$ and
$O_{2}$, $o'$ retains all of the constraints that $c_{1}$ and $c_{2}$ impose
on $O_{1}$ and $O_{2}$, respectively. 

Finally, the set of data that $c'$ stores is constructed as the union
of $c_{1}.stores$ and $c_{2}.stores$ (Line 31).

\todo{example with invokes constraints on SendResp}

\todo{Explain why Alice specified GET and GetPage to be equivalent}

\ek{ \paragraph{\textbf{Remarks}} Note that the merging algorithm
does not enforce any constraint between the arguments of two
operations being merged, or the fields of two data sets. Say
this was intentionally done to make the mapping lightweight}

% To be more precise about what it means for a component to behave like
% another, we use the notion of observational refinement that we
% introduced earlier:
% \begin{thm}
% \label{thm-refinement}
% Given $r \in R$ and $(m_{1}, m_{2}) \in r_{M}$, let $m' = MergeComp(m_{1},
% m_{2}, r_{O})$. Then, $m'$
% is an observation refinement of both $m_{1}$ and $m_{2}$.
% \end{thm}
% \begin{proof}
%   By construction, for every operation $o \in O$ in $m'$ that
%   originated from $m_{1}$, $m'$ retains all of the constraints on $o$
%   from $m_{1}$ (i.e., $m_{1}.cons(o) \subseteq m'.cons(o)$). Thus, $m'.in$
%   and $m'.out$ are subsets of $m_{1}.in$, and $m_{1}.out$, respectively,
%   satisfying the conditions for an observational refinement of $m_{1}$ by
%   $m'$.  Similarly, since $m'$ retains all of the constraints on every
%   operation that it inherits from $m_{2}$, $m'$ is an observational
%   refinement of $m_{2}$.
% \end{proof}
% The key intuition behind the proof is that the merging operation only
% restricts the behaviors of the components on merged operations, and
% retains the same behaviors for all other operations. For example, from
% \txtcname{Client}'s perspective, the merged component
% $\txtcname{AuthorizationServer}_\textsf{TS}$ still behaves like
% \txtcname{AuthorizationServer}, receiving
% requests and sending back an access token only if a valid credential
% is provided.

\subsubsection{Step 2: Building a New Model}

Once the different parts of the models have been merged according to
the given relationships, constructing the merged model is a
straightforward process. Using the function $h_{C}$ that maps a component
from an existing component to its merged counterpart, \txtcname{BuildModel}
simply replaces each of the components that appear in $r_{C}$ with the
new merged one (Line 15), while leaving those that do not appear in
$r_{C}$ intact (Line 17). Similarly, \txtcname{BuildModel} uses $h_{D}$
to replace each of the data sets from $m1$ that appears in $r_{D}$
with its embedded counterpart (Line 20).  

\subsection{Implications of Merging}

Merging two models introduces a new set of behaviors into
the original model of the system, some of which may lead a violation
of a property that prior analyses might have ruled out. We categorize
different types of interactions that arises as a result of
merging. Let $c_1, c_2 \in C$ be components from models $m_{1}$ and
$m_{2}$, $D_1, D_2 \subseteq D$ be data sets from $m_{1}$ and $m_{2}$, and
$O_1, O_2 \subseteq O$ be the sets of operations that $c_1$ and $c_2$
exports, respectively. 

\textbf{A merged component exports additional operations}. Let $c'$ be
the result of merging $c_1$ with $c_2$. Then, $c'$ exports operations
$O_2$, which are absent from $m_1$, introducing new interactions
between $c_1$ and the invokers of $O_2$ in $m_2$. Going back to the
New York Times example in Figure~\ref{fig-nytimes}, by being merged
with \textsf{Browser}, \textsf{Client} obtains two additional
operations, \textsf{ExtractCookie} and \textsf{SetCookie}, allowing
$\textsf{Reader}_\textsf{WebUser}$ to manipulate the counter stored in
$\textsf{Client}_\textsf{Browser}$.

\textbf{A merged operation is invoked by additional components}. Let $O'$
be the result of embedding $O_1$ into $O_2$. Then, $O'$ may be invoked
by all components in $m_2$ that invoke $O_2$, introducing new interactions
between $c_1$ and the invokers of $O_2$ in $m_2$. By being merged with
\textsf{GET}, \textsf{GetPage} becomes a kind of HTTP GET operations;
this means that, for example, any component that invokes \textsf{GET}
may also invoke $\textsf{GetPage}_\textsf{GET}$.

\textbf{A merged data element is included as arguments in additional
  operations.}  Let $D'$ be the result of embedding $D_1$ into
$D_2$. Then, for some $O_2$ that expects an argument $a \in D_2$, a
member of $D'$ may also be substituted for $a$, introducing new flows
of data $D_1$ to the exporters of $O_2$ in $m_2$. Since
$\textsf{Counter}_\textsf{Cookie}$ is now a subset of
$\textsf{Cookie}$, a counter can be provided as the $\textsf{cookie}$
argument in $\textsf{ExtractCookie}$.

It may be a combination of one or more of the above interactions that
lead to a property violation. For example, it is
$\textsf{Reader}_\textsf{WebUser}$ being able to set a cookie inside
$\textsf{Client}_\textsf{Browser}$, combined with the design decision
that a \textsf{Counter} be stored as a \textsf{Cookie}, that allows
the reader to access an article beyond the limit. Then, the task of
the analysis engine is to consider all combinations of interactions
that arise from merging and check whether any one of them could lead
to a violation.

% One
% consequence of the merging is that there are new interactions among
% components that did not exist before. For example, the malicious server
% now interacts with the client application by receiving and sending
% HTTP messages.

% Figure~\ref{fig-merged-oauth-csrf} shows the result of merging the
% OAuth and CSRF models from Figure~\ref{fig-oauth} according to the
% relationships that we specified in Section~\ref{sec-relationship}.
% One example of a CSRF attack against OAuth, made possible due to new
% interactions in the merged model, is as follows. The goal of the
% attacker is to trick the resource owner into granting more resources
% to the client than would be normally desirable by him or her (for
% example, granting write access to the entire Facebook profile, instead
% of just read access). The attack begins when
% $\txtcname{ResourceOwner}_\textsf{EndUser}$ visits a URI that is owned
% by \txtcname{MraliciousServer}, which, then crafts a DOM that is designed
% to force $\txtcname{Client}_\textsf{B}$ into sending
% $\txtcname{reqAccessToken}_\textsf{hreq}$ to
% $\txtcname{AuthorizationServer}_\textsf{TS}$. In particular, this
% request is constructed so that it includes, for argument
% $\txtcname{resID}$, some $\txtcname{badResID}$ $\in$ $\txtcname{ResourceID}$
% that identifies the resource that the attacker wishes to access.

% $\txtcname{Client}_\textsf{B}$, having inherited the behavior of
% \txtcname{Browser}, includes any associated cookies as part of the
% request headers. Since a cookie can be used as a credential,
% $\txtcname{AuthorizationServer}_\textsf{TS}$ accepts this request to be
% valid, and sends back the access token that corresponds to
% $\txtcname{badResID}$, giving $\txtcname{Client}_\textsf{B}$ full access
% to the resource. Note that the attacker was able to bypass the usual
% interactions between $\txtcname{Client}_\textsf{B}$ and
% $\txtcname{ResourceOwner}_\textsf{ES}$ and obtain an access token
% without first gaining permission from the resource owner.
