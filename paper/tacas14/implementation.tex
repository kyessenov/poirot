\section{Implementation}
\label{sec-implementation}

To implement our approach, we (1) designed a domain-specific surface
language (called \sLangLong), and (2) wrote a compiler that translates
models written in \sLang to first-order relational logic (namely the
Alloy language~\cite{alloy}), which is amenable to fully automated
(but bounded) analysis~\cite{kodkod}.

The main design goal of \sLang is to provide a high-level paradigm for
writing formal system designs (architectures) which is intuitive and
readily accessible to analysts not already experienced in formal
methods.  \sLang, therefore, intentionally hides most of the internal
complexities of our declarative formalism; instead, \sLang provides a
mostly imperative service-oriented paradigm, which allows the analyst
to express valid system behaviors simply by specifying service
invocations that different components may perform.  Furthermore,
\sLang is fully embedded in Ruby (all \sLang programs are
syntactically correct Ruby programs), making the extensive set of
existing development tools for Ruby readily available, as well as
making the learning curve less steep.

In this paper, we do not attempt to evaluate the assertions about the
language simplicity and accessibility to non-experts in formal
methods; instead, we invite the community to contribute our existing
knowledge database by downloading \sLang~\cite{slang-web} and
submitting attack models in their domain of expertise.\check{!}

\subsection{The \sLang Language}
\label{sec-impl-slang}
\input{paywall-slang.tex}

\Figref{fig-paywall-slang} shows the implementation of the running
``New York Times Paywall'' example in \sLang.  The main concepts from
our formalism (views, data, components, and operations) are specified
in \sLang by using a pseudo-keyword the same name\footnote{All
  pseudo-keywords in \sLang are implemented as plain Ruby methods}
(e.g., lines 1, 2, 3, 5, 7, etc.).  The containment relation between
them is implicitly defined by the nesting level, much like in Ruby and
the traditional object oriented programs in general.  For instance,
the call to the \bcode{view} function (line 1) defines the
\code{Paywall} view containing all the definitions inside the
\bcode{do ... end} block.  Component definitions can be prepended with
the \bcode{trusted} pseudo-keyword (lines 5, 13) to distinguish
trusted from potentially malicious components (if not explicitly
marked as trusted, the component is considered malicious, e.g., line
22).  Similarly, data definitions can be prepended with
\bcode{critical} (line 2); one of the predefined properties in our
framework checks that no critical data ever flows to a non-trusted
component.  The same syntax (a comma-separated list of
name$\rightarrow$type pairs between square brackets, i.e., a hash in a
singleton array in Ruby terms) is used to specify the data stored in
components (lines 5, 13) and operation arguments (lines 7, 14, 23).
Operations can have guards and responses: the former specifies a
precondition which must hold in order for the operation to be allowed
(e.g., line 8, only when the given argument (\code{currCounter}) is
less than the stored limit (\code{limit})), and the latter specifies
which operations and under what conditions the component invokes
whenever this operation is triggered (e.g., line 9, every time the
\code{GetPage} operation is invoked, the \code{NYTimes} component will
invoke \code{SendPage} of the \code{Client} component, passing the
article corresponding to the given link as the operation argument).

\sLang supports certain declarative constructs as well, so it is not
less expressive than the formalism described in
\secref{sec-formalism}.  For example, operation invocations do not
have to be fully specified, as in the \code{Reader} component which is
allowed to invoke the \code{SelectLink} operation at arbitrary time
points (line 24).  Passing exact arguments to operations is also
unnecessary; arguments can be omitted, or a declarative constraint can
be given to arbitrarily constrain argument values.  A detailed
description of these more advanced features, as well as any discussion
of how the embedding of \sLang in Ruby is actually implemented, are
outside the scope of this paper.

\subsection{Translation to Alloy}
\label{sec-impl-alloy}

Formal analysis of merged models is done entirely at the Alloy level,
by means of running the Alloy Analyzer to automatically check a given
logical property against the system model, within a given finite
scope.  Two standard information flow properties, confidentiality and
integrity, are two built-in checks that our framework automatically
provides for all views; the analyst can separately specify additional,
view-specific, properties to be included in the analysis.

A system trace is represented as a sequence of valid operation
invocations, meaning that at every step of the sequence all
constraints associated with the currently selected operation are
satisfied.  All guards and responses from \sLang models are translated
into declarative constraints on operations, restricting the scope of
valid system traces as little as necessary.  Every subsequent analysis
is then formulated as a problem of finding a trace where a certain
(typically safety or security) property is violated.

%% Before we can express any information flow properties, we first need
%% to define what it means for a component to access data. 
A component is said to \textit{access} certain data at a given step if
(1) it accessed the same data at the previous step, or (2) it is
explicitly designated in the model that the component creates that
kind of data (e.g., \code{NYTimes} creates \code{Article}), or (3) the
operation invoked at the current step is exported by that component
and the data in question is passed as one of the operation's
arguments.

The confidentiality check is formulated as a problem finding a valid
system trace such that at some step \suppress{(in that chain of
  invoked operations) }a malicious component \textit{accesses} a
critical piece of data of a trusted component.  If the Alloy Analyzer
finds a solution to this problem, the confidentiality property is
violated; the returned solution encodes an exact scenario (initial
states of all components and a sequence of operation invocations with
concrete argument values) leading to a violation.  Similarly, the
integrity check is reduced to finding a valid system trace such that
at some step a trusted component accesses some data created by a
malicious component.

